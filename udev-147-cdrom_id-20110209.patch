--- udev-147/extras/cdrom_id/cdrom_id.c	2011-02-09 16:32:05.000000000 +0100
+++ udev-147/extras/cdrom_id/cdrom_id.c	2011-02-09 16:24:43.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * cdrom_id - optical drive and media information prober
  *
- * Copyright (C) 2008 Kay Sievers <kay.sievers@vrfy.org>
+ * Copyright (C) 2008-2010 Kay Sievers <kay.sievers@vrfy.org>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -85,6 +85,8 @@
 static unsigned int cd_media_dvd_rom = 0;
 static unsigned int cd_media_dvd_r = 0;
 static unsigned int cd_media_dvd_rw = 0;
+static unsigned int cd_media_dvd_rw_ro = 0; /* restricted overwrite mode */
+static unsigned int cd_media_dvd_rw_seq = 0; /* sequential mode */
 static unsigned int cd_media_dvd_ram = 0;
 static unsigned int cd_media_dvd_plus_r = 0;
 static unsigned int cd_media_dvd_plus_rw = 0;
@@ -154,19 +156,22 @@
 	struct sg_io_hdr sg_io;
 };
 
-static void scsi_cmd_set(struct udev *udev, struct scsi_cmd *cmd, size_t i, int arg)
+static void scsi_cmd_init(struct udev *udev, struct scsi_cmd *cmd, unsigned char *buf, size_t bufsize)
+{
+	memset(cmd, 0x00, sizeof(struct scsi_cmd));
+	memset(buf, 0x00, bufsize);
+	cmd->cgc.quiet = 1;
+	cmd->cgc.sense = &cmd->_sense.s;
+	memset(&cmd->sg_io, 0, sizeof(cmd->sg_io));
+	cmd->sg_io.interface_id = 'S';
+	cmd->sg_io.mx_sb_len = sizeof(cmd->_sense);
+	cmd->sg_io.cmdp = cmd->cgc.cmd;
+	cmd->sg_io.sbp = cmd->_sense.u;
+	cmd->sg_io.flags = SG_FLAG_LUN_INHIBIT | SG_FLAG_DIRECT_IO;
+}
+
+static void scsi_cmd_set(struct udev *udev, struct scsi_cmd *cmd, size_t i, unsigned char arg)
 {
-	if (i == 0) {
-		memset(cmd, 0x00, sizeof(struct scsi_cmd));
-		cmd->cgc.quiet = 1;
-		cmd->cgc.sense = &cmd->_sense.s;
-		memset(&cmd->sg_io, 0, sizeof(cmd->sg_io));
-		cmd->sg_io.interface_id = 'S';
-		cmd->sg_io.mx_sb_len = sizeof(cmd->_sense);
-		cmd->sg_io.cmdp = cmd->cgc.cmd;
-		cmd->sg_io.sbp = cmd->_sense.u;
-		cmd->sg_io.flags = SG_FLAG_LUN_INHIBIT | SG_FLAG_DIRECT_IO;
-	}
 	cmd->sg_io.cmd_len = i + 1;
 	cmd->cgc.cmd[i] = arg;
 }
@@ -237,12 +242,12 @@
 	unsigned char inq[128];
 	int err;
 
-	memset (inq, 0, sizeof (inq));
+	scsi_cmd_init(udev, &sc, inq, sizeof(inq));
 	scsi_cmd_set(udev, &sc, 0, 0x12);
 	scsi_cmd_set(udev, &sc, 4, 36);
 	scsi_cmd_set(udev, &sc, 5, 0);
 	err = scsi_cmd_run(udev, &sc, fd, inq, 36);
-	if ((err < 0)) {
+	if ((err != 0)) {
 		info_scsi_cmd_err(udev, "INQUIRY", err);
 		return -1;
 	}
@@ -256,178 +261,323 @@
 	return 0;
 }
 
-static int cd_profiles(struct udev *udev, int fd)
+static int feature_profiles(struct udev *udev, const unsigned char *profiles, size_t size)
 {
-	struct scsi_cmd sc;
-	unsigned char header[8];
-	unsigned char profiles[512];
-	unsigned int cur_profile;
-	unsigned int len;
 	unsigned int i;
-	int err;
 
-	memset (header, 0, sizeof (header));
-	scsi_cmd_set(udev, &sc, 0, 0x46);
-	scsi_cmd_set(udev, &sc, 1, 0);
-	scsi_cmd_set(udev, &sc, 8, sizeof(header));
-	scsi_cmd_set(udev, &sc, 9, 0);
-	err = scsi_cmd_run(udev, &sc, fd, header, sizeof(header));
-	if ((err < 0)) {
-		info_scsi_cmd_err(udev, "GET CONFIGURATION", err);
-		return -1;
-	}
-
-	len = 4 + (header[0] << 24 | header[1] << 16 | header[2] << 8 | header[3]);
-	info(udev, "GET CONFIGURATION: number of profiles %i\n", len);
-	if (len > sizeof(profiles)) {
-		info(udev, "invalid number of profiles\n");
-		return -1;
-	}
-
-	memset (profiles, 0, sizeof (profiles));
-	scsi_cmd_set(udev, &sc, 0, 0x46);
-	scsi_cmd_set(udev, &sc, 1, 1);
-	scsi_cmd_set(udev, &sc, 6, len >> 16);
-	scsi_cmd_set(udev, &sc, 7, len >> 8);
-	scsi_cmd_set(udev, &sc, 8, len);
-	scsi_cmd_set(udev, &sc, 9, 0);
-	err = scsi_cmd_run(udev, &sc, fd, profiles, len);
-	if ((err < 0)) {
-		info_scsi_cmd_err(udev, "GET CONFIGURATION", err);
-		return -1;
-	}
-
-	/* device profiles */
-	for (i = 12; i < profiles[11]; i += 4) {
-		unsigned int profile = (profiles[i] << 8 | profiles[i + 1]);
-		if (profile == 0)
-			continue;
-		info(udev, "profile 0x%02x\n", profile);
+	for (i = 0; i+4 <= size; i += 4) {
+		int profile;
 
+		profile = profiles[i] << 8 | profiles[i+1];
 		switch (profile) {
 		case 0x03:
 		case 0x04:
 		case 0x05:
+			info(udev, "profile 0x%02x mo\n", profile);
 			cd_mo = 1;
-		break;
+			break;
+		case 0x08:
+			info(udev, "profile 0x%02x cd_rom\n", profile);
+			cd_cd_rom = 1;
+			break;
+		case 0x09:
+			info(udev, "profile 0x%02x cd_r\n", profile);
+			cd_cd_r = 1;
+			break;
+		case 0x0A:
+			info(udev, "profile 0x%02x cd_rw\n", profile);
+			cd_cd_rw = 1;
+			break;
 		case 0x10:
+			info(udev, "profile 0x%02x dvd_rom\n", profile);
 			cd_dvd_rom = 1;
 			break;
 		case 0x12:
+			info(udev, "profile 0x%02x dvd_ram\n", profile);
 			cd_dvd_ram = 1;
 			break;
 		case 0x13:
 		case 0x14:
+			info(udev, "profile 0x%02x dvd_rw\n", profile);
 			cd_dvd_rw = 1;
 			break;
 		case 0x1B:
+			info(udev, "profile 0x%02x dvd_plus_r\n", profile);
 			cd_dvd_plus_r = 1;
 			break;
 		case 0x1A:
+			info(udev, "profile 0x%02x dvd_plus_rw\n", profile);
 			cd_dvd_plus_rw = 1;
 			break;
 		case 0x2A:
+			info(udev, "profile 0x%02x dvd_plus_rw_dl\n", profile);
 			cd_dvd_plus_rw_dl = 1;
 			break;
 		case 0x2B:
+			info(udev, "profile 0x%02x dvd_plus_r_dl\n", profile);
 			cd_dvd_plus_r_dl = 1;
 			break;
 		case 0x40:
 			cd_bd = 1;
+			info(udev, "profile 0x%02x bd\n", profile);
 			break;
 		case 0x41:
 		case 0x42:
 			cd_bd_r = 1;
+			info(udev, "profile 0x%02x bd_r\n", profile);
 			break;
 		case 0x43:
 			cd_bd_re = 1;
+			info(udev, "profile 0x%02x bd_re\n", profile);
 			break;
 		case 0x50:
 			cd_hddvd = 1;
+			info(udev, "profile 0x%02x hddvd\n", profile);
 			break;
 		case 0x51:
 			cd_hddvd_r = 1;
+			info(udev, "profile 0x%02x hddvd_r\n", profile);
 			break;
 		case 0x52:
 			cd_hddvd_rw = 1;
+			info(udev, "profile 0x%02x hddvd_rw\n", profile);
 			break;
 		default:
+			info(udev, "profile 0x%02x <ignored>\n", profile);
 			break;
 		}
 	}
+	return 0;
+}
 
-	/* current media profile */
-	cur_profile = header[6] << 8 | header[7];
-	info(udev, "current profile 0x%02x\n", cur_profile);
-	if (cur_profile == 0) {
-		info(udev, "no current profile, assuming no media\n");
+static int cd_profiles_old_mmc(struct udev *udev, int fd)
+{
+	struct scsi_cmd sc;
+	int err;
+
+	unsigned char header[32];
+
+	scsi_cmd_init(udev, &sc, header, sizeof(header));
+	scsi_cmd_set(udev, &sc, 0, 0x51);
+	scsi_cmd_set(udev, &sc, 8, sizeof(header));
+	scsi_cmd_set(udev, &sc, 9, 0);
+	err = scsi_cmd_run(udev, &sc, fd, header, sizeof(header));
+	if ((err != 0)) {
+		info_scsi_cmd_err(udev, "READ DISC INFORMATION", err);
+		if (cd_media == 1) {
+			info(udev, "no current profile, but disc is present; assuming CD-ROM\n");
+			cd_media_cd_rom = 1;
+			return 0;
+		} else {
+			info(udev, "no current profile, assuming no media\n");
+			return -1;
+		}
+	};
+
+	cd_media = 1;
+
+	if (header[2] & 16) {
+		cd_media_cd_rw = 1;
+		info(udev, "profile 0x0a media_cd_rw\n");
+	} else if ((header[2] & 3) < 2 && cd_cd_r) {
+		cd_media_cd_r = 1;
+		info(udev, "profile 0x09 media_cd_r\n");
+	} else {
+		cd_media_cd_rom = 1;
+		info(udev, "profile 0x08 media_cd_rom\n");
+	}
+	return 0;
+}
+
+static int cd_profiles(struct udev *udev, int fd)
+{
+	struct scsi_cmd sc;
+	unsigned char features[65530];
+	unsigned int cur_profile = 0;
+	unsigned int len;
+	unsigned int i;
+	int err;
+
+	/* First query the current profile */
+	scsi_cmd_init(udev, &sc, features, sizeof(features));
+	scsi_cmd_set(udev, &sc, 0, 0x46);
+	scsi_cmd_set(udev, &sc, 8, 8);
+	scsi_cmd_set(udev, &sc, 9, 0);
+	err = scsi_cmd_run(udev, &sc, fd, features, 8);
+	if ((err != 0)) {
+		info_scsi_cmd_err(udev, "GET CONFIGURATION", err);
+		/* handle pre-MMC2 drives which do not support GET CONFIGURATION */
+		if (SK(err) == 0x5 && ASC(err) == 0x20) {
+			info(udev, "drive is pre-MMC2 and does not support 46h get configuration command\n");
+			info(udev, "trying to work around the problem\n");
+			return cd_profiles_old_mmc(udev, fd);
+		}
 		return -1;
 	}
 
-	cd_media = 1;
+	cur_profile = features[6] << 8 | features[7];
+	if (cur_profile > 0) {
+		info(udev, "current profile 0x%02x\n", cur_profile);
+	} else {
+		info(udev, "no current profile, assuming no media\n");
+		return -1;
+	}
 
 	switch (cur_profile) {
 	case 0x03:
 	case 0x04:
 	case 0x05:
+		info(udev, "profile 0x%02x \n", cur_profile);
+		cd_media = 1;
 		cd_media_mo = 1;
 		break;
 	case 0x08:
+		info(udev, "profile 0x%02x media_cd_rom\n", cur_profile);
+		cd_media = 1;
 		cd_media_cd_rom = 1;
 		break;
 	case 0x09:
+		info(udev, "profile 0x%02x media_cd_r\n", cur_profile);
+		cd_media = 1;
 		cd_media_cd_r = 1;
 		break;
 	case 0x0a:
+		info(udev, "profile 0x%02x media_cd_rw\n", cur_profile);
+		cd_media = 1;
 		cd_media_cd_rw = 1;
 		break;
 	case 0x10:
+		info(udev, "profile 0x%02x media_dvd_ro\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_rom = 1;
 		break;
 	case 0x11:
+		info(udev, "profile 0x%02x media_dvd_r\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_r = 1;
 		break;
 	case 0x12:
+		info(udev, "profile 0x%02x media_dvd_ram\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_ram = 1;
 		break;
 	case 0x13:
+		info(udev, "profile 0x%02x media_dvd_rw_ro\n", cur_profile);
+		cd_media = 1;
+		cd_media_dvd_rw = 1;
+		cd_media_dvd_rw_ro = 1;
+		break;
 	case 0x14:
+		info(udev, "profile 0x%02x media_dvd_rw_seq\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_rw = 1;
+		cd_media_dvd_rw_seq = 1;
 		break;
 	case 0x1B:
+		info(udev, "profile 0x%02x media_dvd_plus_r\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_plus_r = 1;
 		break;
 	case 0x1A:
+		info(udev, "profile 0x%02x media_dvd_plus_rw\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_plus_rw = 1;
 		break;
 	case 0x2A:
+		info(udev, "profile 0x%02x media_dvd_plus_rw_dl\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_plus_rw_dl = 1;
 		break;
 	case 0x2B:
+		info(udev, "profile 0x%02x media_dvd_plus_r_dl\n", cur_profile);
+		cd_media = 1;
 		cd_media_dvd_plus_r_dl = 1;
 		break;
 	case 0x40:
+		info(udev, "profile 0x%02x media_bd\n", cur_profile);
+		cd_media = 1;
 		cd_media_bd = 1;
 		break;
 	case 0x41:
 	case 0x42:
+		info(udev, "profile 0x%02x media_bd_r\n", cur_profile);
+		cd_media = 1;
 		cd_media_bd_r = 1;
 		break;
 	case 0x43:
+		info(udev, "profile 0x%02x media_bd_re\n", cur_profile);
+		cd_media = 1;
 		cd_media_bd_re = 1;
 		break;
 	case 0x50:
+		info(udev, "profile 0x%02x media_hddvd\n", cur_profile);
+		cd_media = 1;
 		cd_media_hddvd = 1;
 		break;
 	case 0x51:
+		info(udev, "profile 0x%02x media_hddvd_r\n", cur_profile);
+		cd_media = 1;
 		cd_media_hddvd_r = 1;
 		break;
 	case 0x52:
+		info(udev, "profile 0x%02x media_hddvd_rw\n", cur_profile);
+		cd_media = 1;
 		cd_media_hddvd_rw = 1;
 		break;
 	default:
+		info(udev, "profile 0x%02x <ignored>\n", cur_profile);
 		break;
 	}
+
+
+	len = features[0] << 24 | features[1] << 16 | features[2] << 8 | features[3];
+	info(udev, "GET CONFIGURATION: size of features buffer 0x%04x\n", len);
+
+	if (len > sizeof(features)) {
+		info(udev, "can not get features in a single query, truncating\n");
+		len = sizeof(features);
+	} else if (len <= 8) {
+		len = sizeof(features);
+	}
+
+	/* Now get the full feature buffer */
+	scsi_cmd_init(udev, &sc, features,  len);
+	scsi_cmd_set(udev, &sc, 0, 0x46);
+	scsi_cmd_set(udev, &sc, 7, ( len >> 8 ) & 0xff);
+	scsi_cmd_set(udev, &sc, 8, len & 0xff);
+	scsi_cmd_set(udev, &sc, 9, 0);
+	err = scsi_cmd_run(udev, &sc, fd, features, len);
+	if ((err != 0)) {
+		info_scsi_cmd_err(udev, "GET CONFIGURATION", err);
+		return -1;
+	}
+
+	/* parse the length once more, in case the drive decided to have other features suddenly :) */
+	len = features[0] << 24 | features[1] << 16 | features[2] << 8 | features[3];
+	info(udev, "GET CONFIGURATION: size of features buffer 0x%04x\n", len);
+
+	if (len > sizeof(features)) {
+		info(udev, "can not get features in a single query, truncating\n");
+		len = sizeof(features);
+	}
+
+	/* device features */
+	for (i = 8; i+4 < len; i += (4 + features[i+3])) {
+		unsigned int feature;
+
+		feature = features[i] << 8 | features[i+1];
+
+		switch (feature) {
+		case 0x00:
+			info(udev, "GET CONFIGURATION: feature 'profiles', with %i entries\n", features[i+3] / 4);
+			feature_profiles(udev, &features[i]+4, features[i+3]);
+			break;
+		default:
+			info(udev, "GET CONFIGURATION: feature 0x%04x <ignored>, with 0x%02x bytes\n", feature, features[i+3]);
+			break;
+		}
+	}
+
 	return 0;
 }
 
@@ -443,23 +593,139 @@
 	};
 	int err;
 
-	memset (header, 0, sizeof (header));
+	scsi_cmd_init(udev, &sc, header, sizeof(header));
 	scsi_cmd_set(udev, &sc, 0, 0x51);
-	scsi_cmd_set(udev, &sc, 8, sizeof(header));
+	scsi_cmd_set(udev, &sc, 8, sizeof(header) & 0xff);
 	scsi_cmd_set(udev, &sc, 9, 0);
 	err = scsi_cmd_run(udev, &sc, fd, header, sizeof(header));
-	if ((err < 0)) {
+	if ((err != 0)) {
 		info_scsi_cmd_err(udev, "READ DISC INFORMATION", err);
 		return -1;
 	};
 
+	cd_media = 1;
 	info(udev, "disk type %02x\n", header[8]);
+	info(udev, "hardware reported media status: %s\n", media_status[header[2] & 3]);
 
 	/* exclude plain CDROM, some fake cdroms return 0 for "blank" media here */
-	if (!cd_media_cd_rom && (header[2] & 3) < 4)
+	if (!cd_media_cd_rom)
 		cd_media_state = media_status[header[2] & 3];
 
-	if ((header[2] & 3) != 2)
+	/* fresh DVD-RW in restricted overwite mode reports itself as
+	 * "appendable"; change it to "blank" to make it consistent with what
+	 * gets reported after blanking, and what userspace expects  */
+	if (cd_media_dvd_rw_ro && (header[2] & 3) == 1)
+		cd_media_state = media_status[0];
+
+	/* DVD+RW discs (and DVD-RW in restricted mode) once formatted are
+	 * always "complete", DVD-RAM are "other" or "complete" if the disc is
+	 * write protected; we need to check the contents if it is blank */
+	if ((cd_media_dvd_rw_ro || cd_media_dvd_plus_rw || cd_media_dvd_plus_rw_dl || cd_media_dvd_ram) && (header[2] & 3) > 1) {
+		unsigned char buffer[32 * 2048];
+		unsigned char result, len;
+		int block, offset;
+
+		if (cd_media_dvd_ram) {
+			/* a write protected dvd-ram may report "complete" status */
+
+			unsigned char dvdstruct[8];
+			unsigned char format[12];
+
+			scsi_cmd_init(udev, &sc, dvdstruct, sizeof(dvdstruct));
+			scsi_cmd_set(udev, &sc, 0, 0xAD);
+			scsi_cmd_set(udev, &sc, 7, 0xC0);
+			scsi_cmd_set(udev, &sc, 9, sizeof(dvdstruct));
+			scsi_cmd_set(udev, &sc, 11, 0);
+			err = scsi_cmd_run(udev, &sc, fd, dvdstruct, sizeof(dvdstruct));
+			if ((err != 0)) {
+				info_scsi_cmd_err(udev, "READ DVD STRUCTURE", err);
+				return -1;
+			}
+			if (dvdstruct[4] & 0x02) {
+				cd_media_state = media_status[2];
+				info(udev, "write-protected DVD-RAM media inserted\n");
+				goto determined;
+			}
+
+			/* let's make sure we don't try to read unformatted media */
+			scsi_cmd_init(udev, &sc, format, sizeof(format));
+			scsi_cmd_set(udev, &sc, 0, 0x23);
+			scsi_cmd_set(udev, &sc, 8, sizeof(format));
+			scsi_cmd_set(udev, &sc, 9, 0);
+			err = scsi_cmd_run(udev, &sc, fd, format, sizeof(format));
+			if ((err != 0)) {
+				info_scsi_cmd_err(udev, "READ DVD FORMAT CAPACITIES", err);
+				return -1;
+			}
+
+			len = format[3];
+			if (len & 7 || len < 16) {
+				info(udev, "invalid format capacities length\n");
+				return -1;
+			}
+
+			switch(format[8] & 3) {
+			    case 1:
+				info(udev, "unformatted DVD-RAM media inserted\n");
+				/* This means that last format was interrupted
+				 * or failed, blank dvd-ram discs are factory
+				 * formatted. Take no action here as it takes
+				 * quite a while to reformat a dvd-ram and it's
+				 * not automatically started */
+				goto determined;
+
+			    case 2:
+				info(udev, "formatted DVD-RAM media inserted\n");
+				break;
+
+			    case 3:
+				cd_media = 0; //return no media
+				info(udev, "format capacities returned no media\n");
+				return -1;
+			}
+		}
+
+		/* Take a closer look at formatted media (unformatted DVD+RW
+		 * has "blank" status", DVD-RAM was examined earlier) and check
+		 * for ISO and UDF PVDs or a fs superblock presence and do it
+		 * in one ioctl (we need just sectors 0 and 16) */
+		scsi_cmd_init(udev, &sc, buffer, sizeof(buffer));
+		scsi_cmd_set(udev, &sc, 0, 0x28);
+		scsi_cmd_set(udev, &sc, 5, 0);
+		scsi_cmd_set(udev, &sc, 8, 32);
+		scsi_cmd_set(udev, &sc, 9, 0);
+		err = scsi_cmd_run(udev, &sc, fd, buffer, sizeof(buffer));
+		if ((err != 0)) {
+			cd_media = 0;
+			info_scsi_cmd_err(udev, "READ FIRST 32 BLOCKS", err);
+			return -1;
+		}
+
+		/* if any non-zero data is found in sector 16 (iso and udf) or
+		 * eventually 0 (fat32 boot sector, ext2 superblock, etc), disc
+		 * is assumed non-blank */
+		result = 0;
+
+		for (block = 32768; block >= 0 && !result; block -= 32768) {
+			offset = block;
+			while (offset < (block + 2048) && !result) {
+				result = buffer [offset];
+				offset++;
+			}
+		}
+
+		if (!result) {
+			cd_media_state = media_status[0];
+			info(udev, "no data in blocks 0 or 16, assuming blank\n");
+		} else {
+			info(udev, "data in blocks 0 or 16, assuming complete\n");
+		}
+	}
+
+determined:
+	/* "other" is e. g. DVD-RAM, can't append sessions there; DVDs in
+	 * restricted overwrite mode can never append, only in sequential mode */
+	if ((header[2] & 3) < 2 && !cd_media_dvd_rw_ro)
 		cd_media_session_next = header[10] << 8 | header[5];
 	cd_media_session_count = header[9] << 8 | header[4];
 	cd_media_track_count = header[11] << 8 | header[6];
@@ -472,45 +738,50 @@
 	struct scsi_cmd sc;
 	unsigned char header[12];
 	unsigned char toc[2048];
-	unsigned int len, i;
+	unsigned int len, i, num_tracks;
 	unsigned char *p;
 	int err;
 
-	memset (header, 0, sizeof (header));
+	scsi_cmd_init(udev, &sc, header, sizeof(header));
 	scsi_cmd_set(udev, &sc, 0, 0x43);
 	scsi_cmd_set(udev, &sc, 6, 1);
-	scsi_cmd_set(udev, &sc, 8, sizeof(header));
+	scsi_cmd_set(udev, &sc, 8, sizeof(header) & 0xff);
 	scsi_cmd_set(udev, &sc, 9, 0);
 	err = scsi_cmd_run(udev, &sc, fd, header, sizeof(header));
-	if ((err < 0)) {
+	if ((err != 0)) {
 		info_scsi_cmd_err(udev, "READ TOC", err);
 		return -1;
 	}
 
 	len = (header[0] << 8 | header[1]) + 2;
-	info(udev, "READ TOC: len: %d\n", len);
+	info(udev, "READ TOC: len: %d, start track: %d, end track: %d\n", len, header[2], header[3]);
 	if (len > sizeof(toc))
 		return -1;
 	if (len < 2)
 		return -1;
+	/* 2: first track, 3: last track */
+	num_tracks = header[3] - header[2] + 1;
 
 	/* empty media has no tracks */
 	if (len < 8)
 		return 0;
 
-	memset (toc, 0, sizeof (toc));
+	scsi_cmd_init(udev, &sc, toc, sizeof(toc));
 	scsi_cmd_set(udev, &sc, 0, 0x43);
 	scsi_cmd_set(udev, &sc, 6, header[2]); /* First Track/Session Number */
-	scsi_cmd_set(udev, &sc, 7, len >> 8);
-	scsi_cmd_set(udev, &sc, 8, len);
+	scsi_cmd_set(udev, &sc, 7, (len >> 8) & 0xff);
+	scsi_cmd_set(udev, &sc, 8, len & 0xff);
 	scsi_cmd_set(udev, &sc, 9, 0);
 	err = scsi_cmd_run(udev, &sc, fd, toc, len);
-	if ((err < 0)) {
+	if ((err != 0)) {
 		info_scsi_cmd_err(udev, "READ TOC (tracks)", err);
 		return -1;
 	}
 
-	for (p = toc+4, i = 4; i < len-8; i += 8, p += 8) {
+	/* Take care to not iterate beyond the last valid track as specified in
+	 * the TOC, but also avoid going beyond the TOC length, just in case
+	 * the last track number is invalidly large */
+	for (p = toc+4, i = 4; i < len-8 && num_tracks > 0; i += 8, p += 8, --num_tracks) {
 		unsigned int block;
 		unsigned int is_data_track;
 
@@ -526,13 +797,13 @@
 			cd_media_track_count_audio++;
 	}
 
-	memset (header, 0, sizeof (header));
+	scsi_cmd_init(udev, &sc, header, sizeof(header));
 	scsi_cmd_set(udev, &sc, 0, 0x43);
 	scsi_cmd_set(udev, &sc, 2, 1); /* Session Info */
-	scsi_cmd_set(udev, &sc, 8, 12);
+	scsi_cmd_set(udev, &sc, 8, sizeof(header));
 	scsi_cmd_set(udev, &sc, 9, 0);
 	err = scsi_cmd_run(udev, &sc, fd, header, sizeof(header));
-	if ((err < 0)) {
+	if ((err != 0)) {
 		info_scsi_cmd_err(udev, "READ TOC (multi session)", err);
 		return -1;
 	}
@@ -638,12 +909,10 @@
 		goto print;
 
 	/* get session/track info */
-	if (cd_media_toc(udev, fd) < 0)
-		goto print;
+	cd_media_toc(udev, fd);
 
 	/* get writable media state */
-	if (cd_media_info(udev, fd) < 0)
-		goto print;
+	cd_media_info(udev, fd);
 
 print:
 	printf("ID_CDROM=1\n");
@@ -737,14 +1006,14 @@
 		printf("ID_CDROM_MEDIA_SESSION_NEXT=%d\n", cd_media_session_next);
 	if (cd_media_session_count > 0)
 		printf("ID_CDROM_MEDIA_SESSION_COUNT=%d\n", cd_media_session_count);
+	if (cd_media_session_count > 1 && cd_media_session_last_offset > 0)
+		printf("ID_CDROM_MEDIA_SESSION_LAST_OFFSET=%llu\n", cd_media_session_last_offset);
 	if (cd_media_track_count > 0)
 		printf("ID_CDROM_MEDIA_TRACK_COUNT=%d\n", cd_media_track_count);
 	if (cd_media_track_count_audio > 0)
 		printf("ID_CDROM_MEDIA_TRACK_COUNT_AUDIO=%d\n", cd_media_track_count_audio);
 	if (cd_media_track_count_data > 0)
 		printf("ID_CDROM_MEDIA_TRACK_COUNT_DATA=%d\n", cd_media_track_count_data);
-	if (cd_media_session_last_offset > 0)
-		printf("ID_CDROM_MEDIA_SESSION_LAST_OFFSET=%llu\n", cd_media_session_last_offset);
 exit:
 	if (fd >= 0)
 		close(fd);
